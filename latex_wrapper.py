#!/usr/bin/env python3
"""
LaTeX Compilation Wrapper
Detects missing subvariant files and creates placeholders before compilation.
"""

import os
import sys
import re
import subprocess
import tempfile
import shutil
import argparse
from pathlib import Path
from typing import List, Set, Tuple


class LatexCompilationWrapper:
    def __init__(self):
        self.created_files: List[str] = []
        self.temp_dir: Path = None
        
    def find_subvariant_inputs(self, tex_file: Path) -> Set[int]:
        """Find all \input{subvariant_N} commands in the LaTeX file."""
        try:
            with open(tex_file, 'r', encoding='utf-8') as f:
                content = f.read()
        except UnicodeDecodeError:
            # Try with different encoding
            with open(tex_file, 'r', encoding='latin-1') as f:
                content = f.read()
        
        # Pattern to match \input{subvariant_N}
        pattern = r'\\input\{subvariant_(\d+)\}'
        matches = re.findall(pattern, content)
        return set(int(match) for match in matches)
    
    def create_placeholder_subvariant(self, file_path: Path, variant_num: int) -> None:
        """Create a placeholder subvariant file."""
        placeholder_content = f"""% Placeholder for subvariant_{variant_num}
% Auto-generated by LaTeX compilation wrapper
% This file was missing during compilation

\\begin{{itemize}}
\\item Subvariant {variant_num} - Placeholder Content
\\item This is a fallback subvariant generated automatically
\\item Original subvariant file was not found
\\end{{itemize}}

% You can replace this with actual content by creating the proper subvariant_{variant_num}.tex file
"""
        
        # Ensure directory exists
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(placeholder_content)
        
        self.created_files.append(str(file_path))
        print(f"Created placeholder: {file_path}")
    
    def create_missing_subvariants(self, tex_file: Path) -> None:
        """Create missing subvariant files."""
        subvariant_numbers = self.find_subvariant_inputs(tex_file)
        
        if not subvariant_numbers:
            return
        
        tex_dir = tex_file.parent
        
        for variant_num in subvariant_numbers:
            subvariant_path = tex_dir / f"subvariant_{variant_num}.tex"
            
            if not subvariant_path.exists():
                self.create_placeholder_subvariant(subvariant_path, variant_num)
    
    def cleanup_created_files(self) -> None:
        """Clean up all created placeholder files."""
        for file_path in self.created_files:
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    print(f"Cleaned up: {file_path}")
            except Exception as e:
                print(f"Warning: Could not clean up {file_path}: {e}")
        
        self.created_files.clear()
    
    def run_pdflatex(self, args: List[str]) -> int:
        """Run the actual pdflatex compilation."""
        try:
            # Try to find pdflatex in common locations
            pdflatex_cmd = self.find_pdflatex()
            if not pdflatex_cmd:
                print("Error: pdflatex not found. Please ensure MiKTeX or TeX Live is installed.")
                return 1
            
            # Run pdflatex with the provided arguments
            result = subprocess.run([pdflatex_cmd] + args, capture_output=False)
            return result.returncode
            
        except FileNotFoundError:
            print("Error: pdflatex not found. Please ensure LaTeX is installed and in PATH.")
            return 1
        except Exception as e:
            print(f"Error running pdflatex: {e}")
            return 1
    
    def find_pdflatex(self) -> str:
        """Find pdflatex executable."""
        # Common pdflatex locations on Windows
        common_paths = [
            r"C:\Program Files\MiKTeX\miktex\bin\x64\pdflatex.exe",
            r"C:\Program Files (x86)\MiKTeX\miktex\bin\pdflatex.exe",
            r"C:\texlive\2024\bin\windows\pdflatex.exe",
            r"C:\texlive\2023\bin\windows\pdflatex.exe",
        ]
        
        # Check if pdflatex is in PATH
        pdflatex_in_path = shutil.which("pdflatex")
        if pdflatex_in_path:
            return pdflatex_in_path
        
        # Check common installation paths
        for path in common_paths:
            if os.path.exists(path):
                return path
        
        return None
    
    def compile(self, args: List[str], cleanup: bool = True) -> int:
        """Main compilation function."""
        if not args:
            print("Usage: python latex_wrapper.py [pdflatex_options] file.tex")
            return 1
        
        # Find the .tex file in arguments
        tex_file = None
        for arg in args:
            if arg.endswith('.tex'):
                tex_file = Path(arg)
                break
        
        if not tex_file or not tex_file.exists():
            print(f"Error: LaTeX file not found in arguments: {args}")
            return 1
        
        print(f"Processing LaTeX file: {tex_file}")

        try:
            # Create missing subvariants
            self.create_missing_subvariants(tex_file)

            # If the provided tex file is a fragment (no documentclass or begin{document}),
            # create a temporary wrapper with a minimal preamble that defines common macros
            # and includes TikZ so fragments can be compiled standalone.
            tex_text = tex_file.read_text(encoding='utf-8')
            is_fragment = ('\\documentclass' not in tex_text) and ('\\begin{document}' not in tex_text)

            pdflatex_args = args.copy()

            wrapper_path = None
            if is_fragment:
                # create wrapper in same directory 'temp' or system temp
                wrapper_dir = tex_file.parent / 'temp_compile_wrappers'
                wrapper_dir.mkdir(parents=True, exist_ok=True)
                wrapper_path = wrapper_dir / (tex_file.stem + '_wrapper.tex')

                preamble = r'''% Auto-generated wrapper by latex_wrapper.py
\\documentclass[12pt]{article}
\\usepackage[T1]{fontenc}
\\usepackage[utf8]{inputenc}
\\usepackage{lmodern}
\\usepackage{amsmath,amssymb}
\\usepackage{tikz}
\\usepackage{geometry}
\\geometry{paper=a4paper, margin=2.5cm}

% Fallback macro definitions used across exercises
\\providecommand{\\exercicio}[1]{\\section*{}#1}
\\providecommand{\\subexercicio}[1]{\\par\\noindent\\textbf{(a)} #1\\par}

\\begin{document}
\\input{%s}
\\end{document}
'''

                # Write wrapper, using a relative path from wrapper to original tex
                rel_path = os.path.relpath(str(tex_file.resolve()), str(wrapper_path.parent.resolve()))
                with open(wrapper_path, 'w', encoding='utf-8') as f:
                    f.write(preamble % rel_path.replace('\\\\', '/'))

                self.created_files.append(str(wrapper_path))
                print(f"Created wrapper for fragment: {wrapper_path}")

                # Replace the tex file argument for pdflatex with the wrapper
                # Keep other pdflatex options if present
                # Find first .tex in pdflatex_args and replace it
                replaced = False
                for i, a in enumerate(pdflatex_args):
                    if a.endswith('.tex'):
                        pdflatex_args[i] = str(wrapper_path)
                        replaced = True
                        break
                if not replaced:
                    pdflatex_args.append(str(wrapper_path))

            # Run pdflatex
            return_code = self.run_pdflatex(pdflatex_args)

            # Clean up created placeholder/wrapper files if requested and compilation was successful
            if cleanup and return_code == 0:
                self.cleanup_created_files()
            elif self.created_files:
                print(f"Warning: {len(self.created_files)} placeholder/wrapper files were created.")
                print("Run with --cleanup-only to remove them, or check the compilation output.")

            return return_code
            
        except KeyboardInterrupt:
            print("\nCompilation interrupted by user.")
            self.cleanup_created_files()
            return 130
        except Exception as e:
            print(f"Error during compilation: {e}")
            if cleanup:
                self.cleanup_created_files()
            return 1


def main():
    parser = argparse.ArgumentParser(
        description="LaTeX compilation wrapper with subvariant file handling",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python latex_wrapper.py document.tex
  python latex_wrapper.py -interaction=nonstopmode document.tex
  python latex_wrapper.py --no-cleanup document.tex
  python latex_wrapper.py --cleanup-only document.tex
        """
    )
    
    parser.add_argument('pdflatex_args', nargs='*', 
                       help='Arguments to pass to pdflatex (typically just the .tex file)')
    parser.add_argument('--no-cleanup', action='store_true',
                       help='Do not clean up created placeholder files')
    parser.add_argument('--cleanup-only', action='store_true',
                       help='Only clean up placeholder files from previous runs')
    parser.add_argument('--list-missing', action='store_true',
                       help='List missing subvariant files without compiling')
    
    args = parser.parse_args()
    
    wrapper = LatexCompilationWrapper()
    
    if args.cleanup_only:
        # Find and clean up any placeholder files in current directory
        cleaned_count = 0
        for tex_file in Path('.').glob('*.tex'):
            subvariant_numbers = wrapper.find_subvariant_inputs(tex_file)
            tex_dir = tex_file.parent
            
            for variant_num in subvariant_numbers:
                subvariant_path = tex_dir / f"subvariant_{variant_num}.tex"
                
                # Check if it's a placeholder file
                if subvariant_path.exists():
                    try:
                        with open(subvariant_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            if 'Auto-generated by LaTeX compilation wrapper' in content:
                                os.remove(subvariant_path)
                                print(f"Removed placeholder: {subvariant_path}")
                                cleaned_count += 1
                    except Exception:
                        pass
        
        print(f"Cleaned up {cleaned_count} placeholder files.")
        return 0
    
    if args.list_missing:
        if not args.pdflatex_args:
            print("Error: Please specify a .tex file to check for missing subvariants.")
            return 1
        
        tex_file = Path(args.pdflatex_args[0])
        if not tex_file.exists():
            print(f"Error: File {tex_file} not found.")
            return 1
        
        subvariant_numbers = wrapper.find_subvariant_inputs(tex_file)
        missing_files = []
        
        tex_dir = tex_file.parent
        for variant_num in subvariant_numbers:
            subvariant_path = tex_dir / f"subvariant_{variant_num}.tex"
            if not subvariant_path.exists():
                missing_files.append(subvariant_path)
        
        if missing_files:
            print(f"Missing {len(missing_files)} subvariant files:")
            for file_path in missing_files:
                print(f"  - {file_path}")
        else:
            print("All subvariant files are present.")
        
        return 0
    
    # Run compilation
    cleanup = not args.no_cleanup
    return wrapper.compile(args.pdflatex_args, cleanup=cleanup)


if __name__ == "__main__":
    sys.exit(main())